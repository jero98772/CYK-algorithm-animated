import os
def writetxt(name,content,mode="w"):
    """
    Write content to a text file.

    Parameters:
    name (str): The name of the file to write to.
    content (str or any): The content to be written. It will be converted to a string if necessary.
    mode (str, optional): The mode in which to open the file (default is "w" for writing).

    Returns:
    None
    """
    content=str(content)
    with open(name, mode) as file:
        file.write(content)
        file.close()
def read_file(file_path):
    """Reads the contents of a file and returns it as a string.
    
    Args:
        file_path (str): The path to the file to be read.
        
    Returns:
        str: The contents of the file.
        
    Raises:
        FileNotFoundError: If the file does not exist.
        IOError: If an I/O error occurs while reading the file.
    """
    try:
        with open(file_path, 'r') as file:
            content = file.read()
        return content
    except FileNotFoundError:
        print(f"Error: The file '{file_path}' does not exist.")
    except IOError as e:
        print(f"Error: An I/O error occurred while reading the file '{file_path}': {e}")

def parse_grammar(k):
    """
    Parses the grammar rules from input and categorizes them into terminals and non-terminals.

    Args:
        k (int): The number of grammar rules.

    Returns:
        tuple: A tuple containing:
            - grammar (dict): A dictionary where keys are non-terminals and values are lists of productions.
            - list: A list containing:
                - terminals (list): A list of terminal symbols.
                - nonterminals (list): A list of non-terminal symbols.
    """
    grammar = {}
    grammar_special = {}
    terminals=[]
    nonterminals=[]
    # Loop over each rule

    for _ in range(k):
        line = input().split()
        nonterminal = line[0]
        nonterminals.append(nonterminal)
        productions = line[1:]

        # Loop over productions and collect terminal symbols
        for i in productions:
            if i.islower():# the enunciate say if is lowercase is a  terminal 
                terminals.append(i)
        grammar[nonterminal] = productions
    return grammar,[terminals,nonterminals]

def cyk_algorithm(grammar, string):
    """
    Implements the CYK (Cocke-Younger-Kasami) algorithm to check if a string
    can be generated by a given context-free grammar in Chomsky Normal Form (CNF).

    Args:
        grammar (dict): A dictionary representing the grammar where keys are non-terminals 
                        and values are lists of production rules.
        string (str): The input string to check against the grammar.

    Returns:
        tuple: A tuple containing:
            - result (bool): True if the string can be generated by the grammar, False otherwise.
            - table (list of list of sets): The CYK parsing table showing possible non-terminals 
                                            at each substring position.
    """
    n = len(string)
    # Initialize a 2D table with empty sets
    table = [[set() for _ in range(n)] for _ in range(n)]
    
    # Base case: Check for single character matches with grammar rules
    for i in range(n):
        for nonterminal, productions in grammar.items():
            if string[i] in productions:# If the character is in a production rule
                table[i][i].add(nonterminal) # Add the corresponding non-terminal to the table

    # Fill the CYK table for substrings of increasing length (incrementing the size of the window or the k-mers)
    for length in range(2, n + 1): # Start with substrings of length 2
        for i in range(n - length + 1): # Iterate over possible starting points
            j = i + length - 1# Determine the endpoint
            for k in range(i, j):# Split the substring
                for nonterminal, productions in grammar.items():# For each non-terminal
                    for production in productions: # For each production
                        if len(production) == 2:# Because most of the production has two symbols (non-terminals)
                            B, C = production # Get the two symbols
                            # Check if the production can be formed by combining sub-productions
                            if B in table[i][k] and C in table[k+1][j]:
                                table[i][j].add(nonterminal)# Add NON-terminal to the table
                                
    # Return True if the start symbol 'S' can generate the entire string
    return 'S' in table[0][n-1], table

def main():
    """
    Main function to handle input, process the CYK algorithm, and generate output HTML files 
    based on template files.

    - Reads grammar rules and strings to test against the CYK algorithm.
    - Generates HTML files containing the test results, with animations and formatting based on 
      the provided templates.

    Inputs:
        - The first input is the number of test cases (n).
        - For each test case:
            * Two integers: the number of grammar rules (k) and the number of strings to test (m).
            * Next, k lines of grammar rules, followed by m strings.
    
    Outputs:
        - For each string, prints the CYK parsing table and whether the string can be generated ("yes"/"no").
        - Saves the result as an HTML file with animations and formatting in the "animations" folder.
    """
    folder="templates/"
    template_html=folder+"template.html"
    template_css=folder+"cssfile.css"
    template_js=folder+"javascript.js"

    template_code_html=read_file(template_html)
    template_code_css=read_file(template_css)
    template_code_js=read_file(template_js)
    animation_folder="animations"
    if not (os.path.exists(animation_folder) and os.path.isdir(animation_folder)):
        os.mkdir(animation_folder)
    n = int(input()) # Read the number of test cases

    for i in range(n):
        k, m = map(int, input().split())
        grammar,web_data = parse_grammar(k)
        terminals=["a","b"]
        non_terminals=web_data[1]
        for ii in range(m):
            string = input()
            result,matrix = cyk_algorithm(grammar, string)
            #print(matrix)
            answer="yes" if result else "no" # Determine if the string is generated by the grammar
            print(answer)
            #fix cyk javascript
            newcode=template_code_html.format(string='"'+string+'"',terminals=terminals,non_terminals=non_terminals,grammar=grammar,answer=answer)
            # Replace placeholders for JavaScript and CSS with actual template code, if i dont do in this way python confuse with {} of javascript and css
            newcode=newcode.replace("jscode",template_code_js).replace("csscode",template_code_css)
            # Write the generated code to a new HTML file
            writetxt(animation_folder+"/"+f"case_{i}_{ii}.html",newcode)

if __name__ == "__main__":
    main()
